package com.ikplabs.api.repository;

import com.ikplabs.api.entity.GalleryPhoto;
import com.ikplabs.api.entity.PhotoFavorite;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.Optional;

/**
 * PhotoFavoriteRepository - Data access layer for photo favorites
 *
 * ANALOGI SEDERHANA:
 * ==================
 * Repository seperti "Buku Catatan Bookmark Pribadi":
 *
 * Tugas:
 * 1. CATAT siapa favorite foto apa (save favorite)
 * 2. CEK apakah user sudah favorite foto (prevent duplicate)
 * 3. CARI semua foto yang di-favorite user (favorited photos page)
 * 4. HAPUS favorite (unfavorite)
 *
 * PERBEDAAN dengan PhotoLikeRepository:
 * ======================================
 * PhotoLikeRepository:
 * - countByPhotoId() → Public like counter
 * - Purpose: Social engagement metrics
 *
 * PhotoFavoriteRepository:
 * - NO countByPhotoId() ← KEY DIFFERENCE!
 * - Favorites are PRIVATE bookmarks
 * - No public aggregation needed
 * - Only user-specific queries
 *
 * Spring Data JPA otomatis implement method:
 * - save() → Insert new favorite
 * - delete() → Remove favorite
 * - findBy...() → Custom search queries
 *
 * @Repository = Spring otomatis buat instance (singleton)
 */
@Repository
public interface PhotoFavoriteRepository extends JpaRepository<PhotoFavorite, Long> {

    /**
     * Find a favorite by photo ID and user ID
     *
     * Use case: Check if user already favorited a photo before creating new favorite
     *
     * Example:
     * - User 456 clicks star icon on Photo 123
     * - Service calls findByPhotoIdAndUserId(123, 456)
     * - If Optional.empty() → Allow favorite (create new)
     * - If Optional.present() → Already favorited (return error or unfavorite)
     *
     * Database Query (generated by Spring):
     * SELECT * FROM photo_favorites
     * WHERE photo_id = 123 AND user_id = 456
     *
     * Why Optional?
     * - Gracefully handle "not found" case
     * - Avoid null pointer exceptions
     * - isPresent() = favorited, isEmpty() = not favorited
     *
     * @param photoId ID of the photo
     * @param userId ID of the user
     * @return Optional containing PhotoFavorite if exists, empty otherwise
     */
    Optional<PhotoFavorite> findByPhotoIdAndUserId(Long photoId, Long userId);

    /**
     * Check if user has favorited a photo
     *
     * Use case: Quick boolean check (more efficient than findBy)
     *
     * Example:
     * - Frontend needs to show star icon state (filled vs outline)
     * - API returns: { photoId: 123, isFavorited: true }
     * - existsByPhotoIdAndUserId(123, 456) → true/false
     *
     * Database Query:
     * SELECT EXISTS(SELECT 1 FROM photo_favorites
     * WHERE photo_id = 123 AND user_id = 456)
     *
     * Why exists instead of find?
     * - Faster (no need to load entire PhotoFavorite object)
     * - Returns boolean directly
     * - Database optimized for existence checks
     *
     * PRIVACY NOTE:
     * - Only checks for CURRENT user
     * - Cannot check if OTHER users favorited
     * - Privacy by design
     *
     * @param photoId ID of the photo
     * @param userId ID of the user
     * @return true if user favorited photo, false otherwise
     */
    boolean existsByPhotoIdAndUserId(Long photoId, Long userId);

    /**
     * Get all favorited photos for a user (paginated)
     *
     * Use case: Display "Favorited Photos" page for user
     *
     * Example:
     * - User 456 has favorited 50 photos
     * - Page 0, size 12 → Returns first 12 photos (most recent)
     * - Page 1, size 12 → Returns next 12 photos
     *
     * Custom JPQL Query:
     * - JOIN photo_favorites with gallery_photos
     * - Filter by user_id (PRIVACY: only THIS user's favorites!)
     * - Order by created_at DESC (most recent first)
     * - Return GalleryPhoto objects (not PhotoFavorite)
     *
     * Why custom @Query?
     * - We want GalleryPhoto objects, not PhotoFavorite objects
     * - Need to JOIN across tables
     * - Need custom ordering (by favorite time, not photo time)
     *
     * Why Page<GalleryPhoto>?
     * - Page includes: content, totalElements, totalPages, hasNext
     * - Frontend can show: "Showing 1-12 of 50 favorited photos"
     * - Pagination controls: Previous/Next buttons
     *
     * PRIVACY ENFORCEMENT:
     * - WHERE pf.user.id = :userId
     * - Only returns THAT user's favorites
     * - No cross-user data leakage
     * - Controller must extract userId from JWT (not request body!)
     *
     * @param userId ID of the user (from JWT token!)
     * @param pageable Pagination parameters (page, size, sort)
     * @return Page of GalleryPhoto objects favorited by THIS user only
     */
    @Query("SELECT pf.photo FROM PhotoFavorite pf WHERE pf.user.id = :userId ORDER BY pf.createdAt DESC")
    Page<GalleryPhoto> findFavoritedPhotosByUserId(@Param("userId") Long userId, Pageable pageable);

    /**
     * Delete a favorite by photo ID and user ID
     *
     * Use case: Unfavorite operation
     *
     * Example:
     * - User 456 unfavorites Photo 123
     * - Service calls deleteByPhotoIdAndUserId(123, 456)
     * - Spring generates DELETE query
     * - Favorite is removed from database
     *
     * Database Query:
     * DELETE FROM photo_favorites
     * WHERE photo_id = 123 AND user_id = 456
     *
     * Why not delete(PhotoFavorite)?
     * - Don't need to find the PhotoFavorite first
     * - More efficient (single DELETE query)
     * - No SELECT needed
     *
     * Important: Must use @Transactional in Service layer
     * - Deletion must be atomic
     * - If error occurs, rollback
     *
     * @param photoId ID of the photo
     * @param userId ID of the user
     */
    void deleteByPhotoIdAndUserId(Long photoId, Long userId);

    /**
     * NOTES UNTUK PEMAHAMAN:
     * ======================
     *
     * 1. KEY DIFFERENCE: No countByPhotoId()!
     *    PhotoLikeRepository has:
     *    - long countByPhotoId(Long photoId) ← Public counter
     *
     *    PhotoFavoriteRepository does NOT have:
     *    - NO countByPhotoId() ← Privacy by design!
     *    - Favorites are private bookmarks
     *    - No aggregate public counting
     *    - No "X users favorited this" metric
     *
     * 2. Privacy Enforcement:
     *    - All queries user-specific (WHERE user_id = ?)
     *    - No cross-user queries
     *    - No public aggregation
     *    - Controller extracts userId from JWT only
     *
     * 3. Business Rules Difference:
     *    PhotoLike:
     *    - ❌ Cannot like own photos
     *    - ✅ Photo must be public
     *    - ✅ Public counter visible
     *
     *    PhotoFavorite:
     *    - ✅ CAN favorite own photos ← KEY!
     *    - ✅ Can favorite public photos
     *    - ✅ Can favorite own private photos
     *    - ❌ Cannot favorite other users' private photos
     *    - ❌ NO public counter
     *
     * 4. Method Naming Convention:
     *    - findBy{Field}And{Field} → WHERE field1 = ? AND field2 = ?
     *    - existsBy{Field}And{Field} → SELECT EXISTS(WHERE ...)
     *    - deleteBy{Field}And{Field} → DELETE WHERE ...
     *    - NO countBy{Field} for favorites (privacy!)
     *
     * 5. Unique Constraint Handling:
     *    - Database has UNIQUE(photo_id, user_id)
     *    - If duplicate save → DataIntegrityViolationException
     *    - Service layer catches exception → Return 409 Conflict
     *    - Alternative: Check existsByPhotoIdAndUserId first
     *
     * 6. Cascade Deletes:
     *    - Photo deleted → All favorites deleted (ON DELETE CASCADE)
     *    - User deleted → All favorites deleted (ON DELETE CASCADE)
     *    - Automatic cleanup, no orphaned records
     *
     * 7. Transaction Management:
     *    - deleteByPhotoIdAndUserId requires @Transactional
     *    - Service layer handles transactions
     *    - Repository focuses on data access only
     *
     * 8. Performance Optimizations:
     *    - existsByPhotoIdAndUserId → Faster than find (no object load)
     *    - findFavoritedPhotosByUserId → Paginated (not all at once)
     *    - Indexes on photo_id, user_id, created_at
     *
     * 9. Custom JPQL Query:
     *    - @Query("SELECT pf.photo FROM PhotoFavorite pf ...")
     *    - pf = alias for PhotoFavorite
     *    - pf.photo = Navigate to GalleryPhoto (via @ManyToOne)
     *    - pf.user.id = Navigate to User ID
     *    - ORDER BY pf.createdAt DESC = Most recent favorites first
     *
     * 10. Favorite/Unfavorite Flow:
     *
     *     FAVORITE:
     *     1. Check existsByPhotoIdAndUserId(photo, user) → false
     *     2. Privacy check: photo public OR user is owner
     *     3. Create new PhotoFavorite(photo, user)
     *     4. save(photoFavorite) → INSERT into database
     *     5. No counter update (private!)
     *
     *     UNFAVORITE:
     *     1. Check existsByPhotoIdAndUserId(photo, user) → true
     *     2. deleteByPhotoIdAndUserId(photo, user) → DELETE from database
     *     3. No counter update (private!)
     *
     * 11. Favorited Photos Page:
     *     - GET /api/gallery/favorited-photos?page=0&size=12
     *     - Extract userId from JWT (MUST be current user!)
     *     - findFavoritedPhotosByUserId(userId, PageRequest.of(0, 12))
     *     - Returns Page<GalleryPhoto> with 12 photos + metadata
     *     - Frontend shows grid of photos (private collection)
     *     - Pagination: Load more button or page numbers
     *
     * 12. Coexistence with Likes:
     *     - Same photo can be liked AND favorited
     *     - Independent tables (photo_likes vs photo_favorites)
     *     - PhotoResponse DTO includes both:
     *       {
     *         "isLikedByCurrentUser": true,     ← Heart ❤️
     *         "isFavoritedByCurrentUser": true  ← Star ⭐
     *       }
     *
     * 13. Testing Strategy:
     *     - Test existsByPhotoIdAndUserId with existing/non-existing favorite
     *     - Test findFavoritedPhotosByUserId returns only user's favorites
     *     - Test findFavoritedPhotosByUserId pagination works
     *     - Test deleteByPhotoIdAndUserId removes favorite
     *     - Test unique constraint prevents duplicate favorites
     *     - Test cascade deletes when photo/user deleted
     *     - Test privacy: User A cannot see User B's favorites
     *     - Test can favorite own photos (unlike likes!)
     *
     * 14. Security Considerations:
     *     - NEVER accept userId from request body
     *     - ALWAYS extract userId from JWT token
     *     - Validate JWT before any query
     *     - No endpoint to view other users' favorites
     *     - No aggregate favorite counts exposed
     */
}
