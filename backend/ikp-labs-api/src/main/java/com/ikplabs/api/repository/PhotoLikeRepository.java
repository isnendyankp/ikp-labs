package com.ikplabs.api.repository;

import com.ikplabs.api.entity.GalleryPhoto;
import com.ikplabs.api.entity.PhotoLike;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

/**
 * PhotoLikeRepository - Data access layer for photo likes
 *
 * ANALOGI SEDERHANA:
 * ==================
 * Repository seperti "Buku Catatan Like Instagram":
 *
 * Tugas:
 * 1. CATAT siapa like foto apa (save like)
 * 2. CEK apakah user sudah like foto (prevent duplicate)
 * 3. HITUNG berapa banyak like untuk foto (like count)
 * 4. CARI semua foto yang di-like user (liked photos page)
 * 5. HAPUS like (unlike)
 *
 * Spring Data JPA otomatis implement method:
 * - save() → Insert new like
 * - delete() → Remove like
 * - findBy...() → Custom search queries
 *
 * @Repository = Spring otomatis buat instance (singleton)
 */
@Repository
public interface PhotoLikeRepository extends JpaRepository<PhotoLike, Long> {

    /**
     * Find a like by photo ID and user ID
     *
     * Use case: Check if user already liked a photo before creating new like
     *
     * Example:
     * - User 456 clicks like on Photo 123
     * - Service calls findByPhotoIdAndUserId(123, 456)
     * - If Optional.empty() → Allow like (create new)
     * - If Optional.present() → Already liked (return error or unlike)
     *
     * Database Query (generated by Spring):
     * SELECT * FROM photo_likes
     * WHERE photo_id = 123 AND user_id = 456
     *
     * Why Optional?
     * - Gracefully handle "not found" case
     * - Avoid null pointer exceptions
     * - isPresent() = liked, isEmpty() = not liked
     *
     * @param photoId ID of the photo
     * @param userId ID of the user
     * @return Optional containing PhotoLike if exists, empty otherwise
     */
    Optional<PhotoLike> findByPhotoIdAndUserId(Long photoId, Long userId);

    /**
     * Check if user has liked a photo
     *
     * Use case: Quick boolean check (more efficient than findBy)
     *
     * Example:
     * - Frontend needs to show heart icon state (filled vs outline)
     * - API returns: { photoId: 123, isLiked: true, likeCount: 42 }
     * - existsByPhotoIdAndUserId(123, 456) → true/false
     *
     * Database Query:
     * SELECT EXISTS(SELECT 1 FROM photo_likes
     * WHERE photo_id = 123 AND user_id = 456)
     *
     * Why exists instead of find?
     * - Faster (no need to load entire PhotoLike object)
     * - Returns boolean directly
     * - Database optimized for existence checks
     *
     * @param photoId ID of the photo
     * @param userId ID of the user
     * @return true if user liked photo, false otherwise
     */
    boolean existsByPhotoIdAndUserId(Long photoId, Long userId);

    /**
     * Count total likes for a photo
     *
     * Use case: Display like count under photo (e.g., "42 likes")
     *
     * Example:
     * - Photo 123 has been liked by 5 users
     * - countByPhotoId(123) → returns 5
     * - Frontend shows: "❤️ 5"
     *
     * Database Query:
     * SELECT COUNT(*) FROM photo_likes
     * WHERE photo_id = 123
     *
     * Why count instead of findAll?
     * - Don't need actual PhotoLike objects, just the number
     * - More efficient (COUNT is optimized in SQL)
     * - Indexed by photo_id (fast lookup)
     *
     * @param photoId ID of the photo
     * @return Total number of likes for the photo
     */
    long countByPhotoId(Long photoId);

    /**
     * Get all liked photos for a user (paginated)
     *
     * Use case: Display "Liked Photos" page for user
     *
     * Example:
     * - User 456 has liked 50 photos
     * - Page 0, size 12 → Returns first 12 photos (most recent)
     * - Page 1, size 12 → Returns next 12 photos
     *
     * Custom JPQL Query:
     * - JOIN photo_likes with gallery_photos
     * - Filter by user_id
     * - Order by created_at DESC (most recent first)
     * - Return GalleryPhoto objects (not PhotoLike)
     *
     * Why custom @Query?
     * - We want GalleryPhoto objects, not PhotoLike objects
     * - Need to JOIN across tables
     * - Need custom ordering (by like time, not photo time)
     *
     * Why Page<GalleryPhoto>?
     * - Page includes: content, totalElements, totalPages, hasNext
     * - Frontend can show: "Showing 1-12 of 50 photos"
     * - Pagination controls: Previous/Next buttons
     *
     * @param userId ID of the user
     * @param pageable Pagination parameters (page, size, sort)
     * @return Page of GalleryPhoto objects liked by user
     */
    @Query("SELECT pl.photo FROM PhotoLike pl WHERE pl.user.id = :userId ORDER BY pl.createdAt DESC")
    Page<GalleryPhoto> findLikedPhotosByUserId(@Param("userId") Long userId, Pageable pageable);

    /**
     * OPTIMIZED: Get liked photos with JPQL (sortBy=newest)
     *
     * JPQL version avoids native SQL entity mapping issues.
     * Returns photos ordered by created_at DESC (newest first).
     *
     * @param userId ID of the user
     * @param pageable Pagination parameters
     * @return List of liked photos sorted by newest
     */
    @Query("SELECT pl.photo FROM PhotoLike pl WHERE pl.user.id = :userId ORDER BY pl.photo.createdAt DESC")
    List<GalleryPhoto> findLikedPhotosByUserIdNewest(
        @Param("userId") Long userId,
        Pageable pageable
    );

    /**
     * OPTIMIZED: Get liked photos with JPQL (sortBy=oldest)
     *
     * Returns photos ordered by created_at ASC (oldest first).
     *
     * @param userId ID of the user
     * @param pageable Pagination parameters
     * @return List of liked photos sorted by oldest
     */
    @Query("SELECT pl.photo FROM PhotoLike pl WHERE pl.user.id = :userId ORDER BY pl.photo.createdAt ASC")
    List<GalleryPhoto> findLikedPhotosByUserIdOldest(
        @Param("userId") Long userId,
        Pageable pageable
    );

    /**
     * OPTIMIZED: Get liked photos with JPQL (sortBy=mostLiked)
     *
     * Returns photos ordered by like count DESC (most liked first).
     * Uses subquery to count likes for each photo.
     *
     * @param userId ID of the user
     * @param pageable Pagination parameters
     * @return List of liked photos sorted by most liked
     */
    @Query("""
        SELECT pl.photo FROM PhotoLike pl
        WHERE pl.user.id = :userId
        ORDER BY (SELECT COUNT(pl2) FROM PhotoLike pl2 WHERE pl2.photo.id = pl.photo.id) DESC, pl.photo.createdAt DESC
        """)
    List<GalleryPhoto> findLikedPhotosByUserIdMostLiked(
        @Param("userId") Long userId,
        Pageable pageable
    );

    /**
     * OPTIMIZED: Get liked photos with JPQL (sortBy=mostFavorited)
     *
     * Returns photos ordered by favorite count DESC (most favorited first).
     * Uses subquery to count favorites for each photo.
     *
     * @param userId ID of the user
     * @param pageable Pagination parameters
     * @return List of liked photos sorted by most favorited
     */
    @Query("""
        SELECT pl.photo FROM PhotoLike pl
        WHERE pl.user.id = :userId
        ORDER BY (SELECT COUNT(pf) FROM PhotoFavorite pf WHERE pf.photo.id = pl.photo.id) DESC, pl.photo.createdAt DESC
        """)
    List<GalleryPhoto> findLikedPhotosByUserIdMostFavorited(
        @Param("userId") Long userId,
        Pageable pageable
    );

    /**
     * Count total liked photos by user
     *
     * Use case: Calculate total pages for pagination in "Liked Photos" page
     *
     * Example:
     * User has liked 50 photos, page size = 12
     * Total pages = ceil(50 / 12) = 5 pages
     *
     * @param userId ID of the user
     * @return Total number of photos liked by user
     */
    @Query(value = """
        SELECT COUNT(DISTINCT p.id)
        FROM gallery_photos p
        INNER JOIN photo_likes user_like ON p.id = user_like.photo_id AND user_like.user_id = :userId
        """, nativeQuery = true)
    long countLikedPhotosByUserId(@Param("userId") Long userId);

    /**
     * Delete a like by photo ID and user ID
     *
     * Use case: Unlike operation
     *
     * Example:
     * - User 456 unlikes Photo 123
     * - Service calls deleteByPhotoIdAndUserId(123, 456)
     * - Spring generates DELETE query
     * - Like is removed from database
     *
     * Database Query:
     * DELETE FROM photo_likes
     * WHERE photo_id = 123 AND user_id = 456
     *
     * Why not delete(PhotoLike)?
     * - Don't need to find the PhotoLike first
     * - More efficient (single DELETE query)
     * - No SELECT needed
     *
     * Important: Must use @Transactional in Service layer
     * - Deletion must be atomic
     * - If error occurs, rollback
     *
     * @param photoId ID of the photo
     * @param userId ID of the user
     */
    void deleteByPhotoIdAndUserId(Long photoId, Long userId);

    /**
     * Delete all likes for photos owned by a specific user
     *
     * Use case: Cascade delete when user is deleted (test cleanup)
     *
     * Example:
     * - User 456 is being deleted (test cleanup)
     * - Service calls deleteByPhotoUserId(456)
     * - All likes on User 456's photos are removed
     *
     * Database Query:
     * DELETE FROM photo_likes
     * WHERE photo_id IN (SELECT id FROM gallery_photos WHERE user_id = 456)
     *
     * Important: Must use @Transactional in Service layer
     *
     * @param userId ID of the photo owner
     */
    @Modifying
    @Query("DELETE FROM PhotoLike pl WHERE pl.photo.user.id = :userId")
    void deleteByPhotoUserId(@Param("userId") Long userId);

    /**
     * NOTES UNTUK PEMAHAMAN:
     * ======================
     *
     * 1. Kenapa extends JpaRepository?
     *    - Dapat method gratis: save, delete, findById, etc.
     *    - Spring Data JPA otomatis implement
     *    - PhotoLike = entity type, Long = ID type
     *
     * 2. Method Naming Convention:
     *    - findBy{Field}And{Field} → WHERE field1 = ? AND field2 = ?
     *    - existsBy{Field}And{Field} → SELECT EXISTS(WHERE ...)
     *    - countBy{Field} → SELECT COUNT(*) WHERE ...
     *    - deleteBy{Field}And{Field} → DELETE WHERE ...
     *
     * 3. Unique Constraint Handling:
     *    - Database has UNIQUE(photo_id, user_id)
     *    - If duplicate save → DataIntegrityViolationException
     *    - Service layer catches exception → Return 409 Conflict
     *    - Alternative: Check existsByPhotoIdAndUserId first
     *
     * 4. Cascade Deletes:
     *    - Photo deleted → All likes deleted (ON DELETE CASCADE)
     *    - User deleted → All likes deleted (ON DELETE CASCADE)
     *    - Automatic cleanup, no orphaned records
     *
     * 5. Transaction Management:
     *    - deleteByPhotoIdAndUserId requires @Transactional
     *    - Service layer handles transactions
     *    - Repository focuses on data access only
     *
     * 6. Performance Optimizations:
     *    - existsByPhotoIdAndUserId → Faster than find (no object load)
     *    - countByPhotoId → Uses COUNT(*), indexed by photo_id
     *    - findLikedPhotosByUserId → Paginated (not all at once)
     *    - Indexes on photo_id, user_id, created_at
     *
     * 7. Custom JPQL Query:
     *    - @Query("SELECT pl.photo FROM PhotoLike pl ...")
     *    - pl = alias for PhotoLike
     *    - pl.photo = Navigate to GalleryPhoto (via @ManyToOne)
     *    - pl.user.id = Navigate to User ID
     *    - ORDER BY pl.createdAt DESC = Most recent likes first
     *
     * 8. Why Page vs List?
     *    - Page includes pagination metadata
     *    - List just returns items
     *    - Page better for UI (show page numbers)
     *    - Example: Page<GalleryPhoto> has getTotalPages(), hasNext(), etc.
     *
     * 9. Like/Unlike Flow:
     *
     *    LIKE:
     *    1. Check existsByPhotoIdAndUserId(photo, user) → false
     *    2. Create new PhotoLike(photo, user)
     *    3. save(photoLike) → INSERT into database
     *    4. countByPhotoId(photo) → New count for frontend
     *
     *    UNLIKE:
     *    1. Check existsByPhotoIdAndUserId(photo, user) → true
     *    2. deleteByPhotoIdAndUserId(photo, user) → DELETE from database
     *    3. countByPhotoId(photo) → Updated count for frontend
     *
     * 10. Liked Photos Page:
     *     - GET /api/gallery/liked-photos?page=0&size=12
     *     - findLikedPhotosByUserId(userId, PageRequest.of(0, 12))
     *     - Returns Page<GalleryPhoto> with 12 photos + metadata
     *     - Frontend shows grid of photos
     *     - Pagination: Load more button or page numbers
     *
     * 11. Testing Strategy:
     *     - Test existsByPhotoIdAndUserId with existing/non-existing like
     *     - Test countByPhotoId returns correct count
     *     - Test findLikedPhotosByUserId pagination works
     *     - Test deleteByPhotoIdAndUserId removes like
     *     - Test unique constraint prevents duplicate likes
     *     - Test cascade deletes when photo/user deleted
     *
     * 12. Why @Param annotation in @Query?
     *     - Maps method parameter to JPQL parameter
     *     - :userId in query → @Param("userId") Long userId
     *     - Required for custom queries with parameters
     *     - Makes query more readable
     */
}
