package com.ikplabs.api.repository;

import com.ikplabs.api.entity.GalleryPhoto;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

/**
 * GalleryPhotoRepository - Data access layer for gallery photos
 *
 * ANALOGI SEDERHANA:
 * ==================
 * Repository seperti "Petugas Arsip Perpustakaan":
 *
 * Tugas:
 * 1. CARI foto berdasarkan kriteria (user, public/private)
 * 2. HITUNG berapa banyak foto (untuk pagination)
 * 3. SIMPAN foto baru ke "rak" database
 * 4. HAPUS foto dari "rak" database
 *
 * Spring Data JPA otomatis implement method:
 * - findById() â†’ Cari foto by ID
 * - save() â†’ Simpan foto baru atau update
 * - delete() â†’ Hapus foto
 * - Custom queries untuk filtering
 *
 * @Repository = Spring otomatis buat instance (singleton)
 */
@Repository
public interface GalleryPhotoRepository extends JpaRepository<GalleryPhoto, Long> {

    /**
     * Find all photos by user ID (paginated)
     *
     * Use case: Get all photos for a specific user in "My Gallery"
     * Returns: Both public and private photos (for owner only)
     *
     * Example:
     * User 83 has 25 photos total.
     * Request page 0, size 20 â†’ Returns first 20 photos
     * Request page 1, size 20 â†’ Returns last 5 photos
     *
     * @param userId ID of the user who owns the photos
     * @param pageable Pagination parameters (page number, page size, sort)
     * @return List of photos for the user (paginated)
     */
    List<GalleryPhoto> findByUserId(Long userId, Pageable pageable);

    /**
     * Find all PUBLIC photos (paginated)
     *
     * Use case: Get all public photos for "Public Gallery" page
     * Returns: Only photos where is_public = TRUE
     * Accessible by: Anyone (authenticated or anonymous)
     *
     * Database Query (generated by Spring):
     * SELECT * FROM gallery_photos
     * WHERE is_public = TRUE
     * ORDER BY created_at DESC
     * LIMIT {size} OFFSET {page * size}
     *
     * Why @Query annotation?
     * - Make it explicit that we're filtering by isPublic
     * - Better readability
     * - Can optimize if needed
     *
     * @param pageable Pagination parameters
     * @return List of public photos only (paginated)
     */
    @Query("SELECT p FROM GalleryPhoto p WHERE p.isPublic = TRUE")
    List<GalleryPhoto> findByIsPublicTrue(Pageable pageable);

    /**
     * Find user's PUBLIC photos only (paginated)
     *
     * Use case: View specific user's public photos
     * Example: /api/gallery/public/83 â†’ Show User 83's public photos
     *
     * Filters:
     * 1. user_id = {userId}
     * 2. is_public = TRUE
     *
     * Why this method?
     * - Users might have both public and private photos
     * - We only want to show their public photos to others
     * - Owner can see all via findByUserId()
     *
     * @param userId ID of the user
     * @param pageable Pagination parameters
     * @return List of user's public photos only (paginated)
     */
    List<GalleryPhoto> findByUserIdAndIsPublicTrue(Long userId, Pageable pageable);

    /**
     * Count total photos by user
     *
     * Use case: Calculate total pages for pagination in "My Gallery"
     *
     * Example:
     * User has 25 photos, page size = 20
     * Total pages = ceil(25 / 20) = 2 pages
     *
     * @param userId ID of the user
     * @return Total number of photos for the user
     */
    Long countByUserId(Long userId);

    /**
     * Count total PUBLIC photos
     *
     * Use case: Calculate total pages for pagination in "Public Gallery"
     *
     * Example:
     * Database has 100 public photos, page size = 20
     * Total pages = ceil(100 / 20) = 5 pages
     *
     * @return Total number of public photos
     */
    Long countByIsPublicTrue();

    /**
     * Count user's PUBLIC photos
     *
     * Use case: Calculate total pages when viewing specific user's public photos
     *
     * @param userId ID of the user
     * @return Total number of user's public photos
     */
    Long countByUserIdAndIsPublicTrue(Long userId);

    /**
     * OPTIMIZED: Find user's photos with like/favorite counts and sorting
     *
     * Solves N+1 problem by using LEFT JOINs to get counts in single query.
     * Supports dynamic sorting by: newest, oldest, mostLiked, mostFavorited
     *
     * Native SQL Query (optimized for performance):
     * - LEFT JOIN photo_likes â†’ Count likes per photo
     * - LEFT JOIN photo_favorites â†’ Count favorites per photo
     * - Single query instead of 1 + N queries
     * - Dynamic ORDER BY based on sortBy parameter
     *
     * Performance:
     * - Before: 1 query for photos + N queries for counts = 1 + N queries
     * - After: 1 query for everything = 96% reduction (if N=25)
     * - Example: 26 queries â†’ 1 query
     *
     * @param userId ID of the user
     * @param sortBy Sort option: "newest", "oldest", "mostLiked", "mostFavorited"
     * @param pageable Pagination parameters
     * @return List of photos with counts (sorted)
     */
    @Query(value = """
        SELECT p.*
        FROM gallery_photos p
        LEFT JOIN photo_likes pl ON p.id = pl.photo_id
        LEFT JOIN photo_favorites pf ON p.id = pf.photo_id
        WHERE p.user_id = :userId
        GROUP BY p.id
        ORDER BY
            CASE WHEN :sortBy = 'newest' THEN p.created_at END DESC,
            CASE WHEN :sortBy = 'oldest' THEN p.created_at END ASC,
            CASE WHEN :sortBy = 'mostLiked' THEN COUNT(DISTINCT pl.id) END DESC,
            CASE WHEN :sortBy = 'mostFavorited' THEN COUNT(DISTINCT pf.id) END DESC,
            p.created_at DESC
        """, nativeQuery = true)
    List<GalleryPhoto> findByUserIdWithCounts(
        @Param("userId") Long userId,
        @Param("sortBy") String sortBy,
        Pageable pageable
    );

    /**
     * OPTIMIZED: Find public photos with like/favorite counts and sorting
     *
     * Same optimization as findByUserIdWithCounts but for public photos only.
     * Filters by is_public = TRUE.
     *
     * @param sortBy Sort option: "newest", "oldest", "mostLiked", "mostFavorited"
     * @param pageable Pagination parameters
     * @return List of public photos with counts (sorted)
     */
    @Query(value = """
        SELECT p.*
        FROM gallery_photos p
        LEFT JOIN photo_likes pl ON p.id = pl.photo_id
        LEFT JOIN photo_favorites pf ON p.id = pf.photo_id
        WHERE p.is_public = TRUE
        GROUP BY p.id
        ORDER BY
            CASE WHEN :sortBy = 'newest' THEN p.created_at END DESC,
            CASE WHEN :sortBy = 'oldest' THEN p.created_at END ASC,
            CASE WHEN :sortBy = 'mostLiked' THEN COUNT(DISTINCT pl.id) END DESC,
            CASE WHEN :sortBy = 'mostFavorited' THEN COUNT(DISTINCT pf.id) END DESC,
            p.created_at DESC
        """, nativeQuery = true)
    List<GalleryPhoto> findPublicPhotosWithCounts(
        @Param("sortBy") String sortBy,
        Pageable pageable
    );

    /**
     * NOTES UNTUK PEMAHAMAN:
     * ======================
     *
     * 1. Kenapa extends JpaRepository?
     *    - Dapat method gratis: findById, save, delete, findAll, etc.
     *    - Spring Data JPA otomatis implement
     *    - Tidak perlu tulis SQL manual
     *
     * 2. Kenapa pakai Pageable?
     *    - Handle large datasets (100+ photos)
     *    - User tidak perlu load semua sekaligus
     *    - Better performance (only query what's needed)
     *    - Example: Pageable.of(0, 20) = page 1, 20 items
     *
     * 3. Method Naming Convention:
     *    - findBy{Field} â†’ Spring generate query otomatis
     *    - findByUserId â†’ WHERE user_id = ?
     *    - findByIsPublicTrue â†’ WHERE is_public = TRUE
     *    - findByUserIdAndIsPublicTrue â†’ WHERE user_id = ? AND is_public = TRUE
     *
     * 4. Count Methods:
     *    - Needed untuk pagination metadata
     *    - Frontend perlu tahu: total pages, current page, has next
     *    - Example response: { totalPhotos: 25, totalPages: 2, currentPage: 0 }
     *
     * 5. Privacy Filtering:
     *    - findByUserId â†’ Returns ALL (public + private) for owner
     *    - findByIsPublicTrue â†’ Returns ONLY public for everyone
     *    - findByUserIdAndIsPublicTrue â†’ Returns ONLY user's public for others
     *
     * 6. Why interface not class?
     *    - Spring Data JPA create implementation at runtime
     *    - We only define method signatures
     *    - Spring generate SQL based on method name
     *    - Magic! ðŸª„
     *
     * 7. Cascade Delete:
     *    - Defined in GalleryPhoto entity: @ManyToOne with CASCADE
     *    - User deleted â†’ All photos automatically deleted
     *    - No need for manual cleanup method
     *
     * 8. Index Usage:
     *    - user_id indexed â†’ Fast findByUserId queries
     *    - is_public indexed â†’ Fast findByIsPublicTrue queries
     *    - Both â†’ Fast compound queries
     *    - Defined in migration SQL
     *
     * 9. Testing:
     *    - Use @DataJpaTest for repository tests
     *    - Test pagination works correctly
     *    - Test privacy filtering (no private photos leak)
     *    - Test count methods return correct numbers
     */

    /**
     * Delete all photos owned by a specific user
     *
     * Use case: Cascade delete when user is deleted (test cleanup)
     *
     * Example:
     * - User 456 is being deleted (test cleanup)
     * - Service calls deleteByUserId(456)
     * - All photos owned by User 456 are removed
     *
     * Database Query:
     * DELETE FROM gallery_photos WHERE user_id = 456
     *
     * Important: Must use @Transactional in Service layer
     *
     * @param userId ID of the photo owner
     */
    @Modifying
    @Query("DELETE FROM GalleryPhoto gp WHERE gp.user.id = :userId")
    void deleteByUserId(@Param("userId") Long userId);
}
